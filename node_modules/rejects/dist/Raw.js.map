{"version":3,"sources":["Raw.ts"],"names":[],"mappings":";;AAAA,IAAY,OAOX;AAPD,WAAY,OAAO;IACjB,4BAAiB,CAAA;IACjB,4BAAiB,CAAA;IACjB,8BAAmB,CAAA;IACnB,wBAAa,CAAA;IACb,kCAAuB,CAAA;IACvB,4BAAiB,CAAA;AACnB,CAAC,EAPW,OAAO,GAAP,eAAO,KAAP,eAAO,QAOlB;AAED,MAAM,KAAK,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC;AAI7E,MAAqB,GAAI,SAAQ,MAAM;IAC9B,MAAM,CAAC,WAAW,CAAC,GAAQ;QAChC,OAAO,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,CAAC;IACtE,CAAC;IAEM,MAAM,CAAC,EAAE,CAAC,GAAQ;QACvB,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAC3D,CAAC;IAKD,YAAY,GAAc;QACxB,IAAI,IAAwB,CAAC;QAC7B,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE;YACf,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3B,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5C,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM;gBAAE,MAAM,IAAI,KAAK,CAAC,8BAA8B,GAAG,EAAE,CAAC,CAAC;YAEhF,KAAK,CAAC,GAAG,CAAC,CAAC;YACX,GAAG,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAEnC,QAAQ,IAAI,EAAE;gBACZ,KAAK,OAAO,CAAC,OAAO;oBAClB,GAAG,GAAG,GAAG,KAAK,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;oBACpC,MAAM;gBACR,KAAK,OAAO,CAAC,IAAI;oBACf,GAAG,GAAG,IAAI,CAAC;oBACX,MAAM;gBACR,KAAK,OAAO,CAAC,MAAM;oBACjB,GAAG,GAAG,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;oBAC1D,MAAM;gBACR,KAAK,OAAO,CAAC,MAAM;oBACjB,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;oBAClB,MAAM;gBACR,KAAK,OAAO,CAAC,SAAS;oBACpB,GAAG,GAAG,SAAS,CAAC;oBAChB,MAAM;gBACR,KAAK,OAAO,CAAC,MAAM;oBACjB,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;oBAClB,MAAM;gBACR;oBACE,MAAM,IAAI,KAAK,CAAC,oDAAoD,IAAI,GAAG,CAAC,CAAC;aAChF;SACF;aAAM;YACL,IAAI,GAAG,GAAG,KAAK,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,GAAG,CAAC;YAC1C,KAAK,CAAC,OAAO,IAAI,IAAI,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;SACrC;QAED,IAAI,CAAC,IAAI,GAAG,IAAe,CAAC;QAC5B,IAAI,CAAC,KAAK,GAAG,GAAgB,CAAC;IAChC,CAAC;CACF;AApDD,sBAoDC","file":"Raw.js","sourcesContent":["export enum RawType {\n  STRING = 'string',\n  NUMBER = 'number',\n  BOOLEAN = 'boolean',\n  NULL = 'null',\n  UNDEFINED = 'undefined',\n  SYMBOL = 'symbol',\n}\n\nconst types = ['string', 'number', 'boolean', 'null', 'undefined', 'symbol'];\n\nexport type Primitive = boolean | number | string | symbol | null | undefined;\n\nexport default class Raw extends String {\n  public static isPrimitive(val: any): val is Primitive {\n    return val === null || !['function', 'object'].includes(typeof val);\n  }\n\n  public static is(str: any): str is string {\n    return typeof str === 'string' && str.startsWith('raw:');\n  }\n\n  public type: RawType;\n  public value: Primitive;\n\n  constructor(val: Primitive) {\n    let type: string | undefined;\n    if (Raw.is(val)) {\n      const slice = val.slice(4);\n      type = types.find(t => slice.startsWith(t));\n      if (!type || !type.length) throw new Error(`invalid raw type for value ${val}`);\n\n      super(val);\n      val = slice.slice(type.length + 1);\n\n      switch (type) {\n        case RawType.BOOLEAN:\n          val = val === 'true' ? true : false;\n          break;\n        case RawType.NULL:\n          val = null;\n          break;\n        case RawType.NUMBER:\n          val = val.includes('.') ? parseFloat(val) : parseInt(val);\n          break;\n        case RawType.SYMBOL:\n          val = Symbol(val);\n          break;\n        case RawType.UNDEFINED:\n          val = undefined;\n          break;\n        case RawType.STRING:\n          val = String(val);\n          break;\n        default:\n          throw new Error(`attempted to derive raw value from invalid type \"${type}\"`);\n      }\n    } else {\n      type = val === null ? 'null' : typeof val;\n      super(`raw:${type}:${String(val)}`);\n    }\n\n    this.type = type as RawType;\n    this.value = val as Primitive;\n  }\n}\n"],"sourceRoot":"../src"}