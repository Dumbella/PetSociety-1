{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import * as Redis from 'ioredis';\nimport { isEmpty, isObjectLike } from 'lodash';\nimport hyperid = require('hyperid');\nimport Raw, { RawType } from './Raw';\nimport Reference, { ReferenceType } from './Reference';\n\nexport default class Rejects {\n  public generateID: () => string;\n\n  constructor(public readonly client: Redis.Redis) {\n    this.generateID = hyperid();\n  }\n\n  public async delete(key: string): Promise<number> {\n    const data = await this.client.hgetall(key);\n    const promises: Promise<number>[] = [];\n\n    for (const ref of Object.values(data) as string[]) {\n      if (Reference.is(ref)) {\n        const { key: newKey } = new Reference(ref);\n        promises.push(this.delete(newKey));\n      }\n    }\n\n    if (promises.length) await Promise.all(promises);\n    return this.client.del(key);\n  }\n\n  public upsert(key: string, obj: object, pipeline: Redis.Pipeline = this.client.pipeline()): PromiseLike<[Error | null, 'OK'][]> {\n    if (key.includes('.')) {\n      const route = key.split('.');\n      let newKey: string | undefined;\n      while (newKey = route.pop()) {\n        if (route.length) {\n          obj = { [newKey]: obj };\n        } else {\n          key = newKey;\n          break;\n        }\n      }\n    }\n\n    return this._upsert(key, obj, { seen: [], pipeline }).exec();\n  }\n\n  protected _upsert(\n    rootKey: string,\n    obj: object,\n    opts: {\n      pipeline: Redis.Pipeline;\n      seen: any[];\n    },\n  ): Redis.Pipeline {\n    if (isEmpty(obj)) return opts.pipeline;\n\n    if (opts.seen.includes(obj)) throw new TypeError('cannot store circular structure in Redis');\n    if (isObjectLike(obj)) opts.seen.push(obj);\n\n    const toSet: string[] = [];\n    const isArray = Array.isArray(obj);\n    for (let [key, value] of Object.entries(obj)) {\n      if (isArray) key = this.generateID();\n      if (Raw.isPrimitive(value)) {\n        value = new Raw(value).toString();\n      } else {\n        const newKey = rootKey.concat('.', key);\n        this._upsert(newKey, value, opts);\n        value = new Reference(newKey, Array.isArray(value) ? ReferenceType.ARRAY : ReferenceType.OBJECT).toString();\n      }\n\n      toSet.push(key, value);\n    }\n\n    return opts.pipeline.hmset(rootKey, toSet);\n  }\n\n  public async set(key: string, obj: object, pipeline?: Redis.Pipeline): Promise<[Error | null, 'OK'][]> {\n    await this.delete(key);\n    return this.upsert(key, obj, pipeline);\n  }\n\n  public async get<T = any>(key: string, opts?: { type?: ReferenceType, depth?: number }): Promise<T | null> {\n    return this._get<T>(key, opts);\n  }\n\n  protected async _get<T>(\n    rootKey: string,\n    {\n      type = ReferenceType.OBJECT,\n      depth = -1,\n      currentDepth = 0\n    }: {\n      type?: ReferenceType;\n      depth?: number;\n      currentDepth?: number;\n    } = {}\n  ): Promise<T | null> {\n    const data = await this.client.hgetall(rootKey);\n\n    // handle empty data\n    if (isEmpty(data)) {\n      const exists = await this.client.exists(rootKey);\n      if (exists || !type) return null;\n      return type === ReferenceType.ARRAY ? [] as any : {} as any;\n    }\n\n    if (depth < 0 || currentDepth < depth) {\n      const nested: [string, Promise<T | null>][] = [];\n      for (const [key, val] of Object.entries(data) as [string, string][]) {\n        if (Raw.is(val)) {\n          data[key] = new Raw(val).value;\n        } else if (Reference.is(val)) {\n          const { type, key: newKey } = new Reference(val);\n          nested.push([key, this._get(newKey, { type, depth, currentDepth: currentDepth + 1 })]);\n        } else {\n          throw new Error(`unrecognized hash entry \"${key}\".\"${val}\" on key ${rootKey}`);\n        }\n      }\n\n      await Promise.all(nested.map(async ([key, call]) => data[key] = await call));\n    }\n\n    return type === ReferenceType.ARRAY ? Object.values(data) : data;\n  }\n\n  public incr(key: string, amt: number = 1): PromiseLike<number> {\n    if (!key.includes('.')) return Promise.reject(new Error(`key \"${key}\" does not contain any fields`));\n    const isFloat = Math.floor(amt) !== amt;\n\n    const route = key.split('.');\n    const field = route.pop();\n    if (field && route.length) {\n      if (isFloat) return this.client.hincrbyfloat(route.join('.'), field, amt);\n      return this.client.hincrby(route.join('.'), field, amt);\n    }\n\n    return Promise.reject(new Error(`error parsing key \"${key}\" for increment`));\n  }\n\n  public keys(key: string): PromiseLike<string[]> {\n    return this.client.hkeys(key);\n  }\n\n  public size(key: string): PromiseLike<number> {\n    return this.client.hlen(key);\n  }\n}\n\nexport {\n  Raw,\n  RawType,\n  Reference,\n  ReferenceType,\n  Rejects,\n}\n"],"sourceRoot":"../src"}