"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const hyperid = require("hyperid");
const Raw_1 = require("./Raw");
exports.Raw = Raw_1.default;
exports.RawType = Raw_1.RawType;
const Reference_1 = require("./Reference");
exports.Reference = Reference_1.default;
exports.ReferenceType = Reference_1.ReferenceType;
class Rejects {
    constructor(client) {
        this.client = client;
        this.generateID = hyperid();
    }
    async delete(key) {
        const data = await this.client.hgetall(key);
        const promises = [];
        for (const ref of Object.values(data)) {
            if (Reference_1.default.is(ref)) {
                const { key: newKey } = new Reference_1.default(ref);
                promises.push(this.delete(newKey));
            }
        }
        if (promises.length)
            await Promise.all(promises);
        return this.client.del(key);
    }
    upsert(key, obj, pipeline = this.client.pipeline()) {
        if (key.includes('.')) {
            const route = key.split('.');
            let newKey;
            while (newKey = route.pop()) {
                if (route.length) {
                    obj = { [newKey]: obj };
                }
                else {
                    key = newKey;
                    break;
                }
            }
        }
        return this._upsert(key, obj, { seen: [], pipeline }).exec();
    }
    _upsert(rootKey, obj, opts) {
        if (lodash_1.isEmpty(obj))
            return opts.pipeline;
        if (opts.seen.includes(obj))
            throw new TypeError('cannot store circular structure in Redis');
        if (lodash_1.isObjectLike(obj))
            opts.seen.push(obj);
        const toSet = [];
        const isArray = Array.isArray(obj);
        for (let [key, value] of Object.entries(obj)) {
            if (isArray)
                key = this.generateID();
            if (Raw_1.default.isPrimitive(value)) {
                value = new Raw_1.default(value).toString();
            }
            else {
                const newKey = rootKey.concat('.', key);
                this._upsert(newKey, value, opts);
                value = new Reference_1.default(newKey, Array.isArray(value) ? Reference_1.ReferenceType.ARRAY : Reference_1.ReferenceType.OBJECT).toString();
            }
            toSet.push(key, value);
        }
        return opts.pipeline.hmset(rootKey, toSet);
    }
    async set(key, obj, pipeline) {
        await this.delete(key);
        return this.upsert(key, obj, pipeline);
    }
    async get(key, opts) {
        return this._get(key, opts);
    }
    async _get(rootKey, { type = Reference_1.ReferenceType.OBJECT, depth = -1, currentDepth = 0 } = {}) {
        const data = await this.client.hgetall(rootKey);
        // handle empty data
        if (lodash_1.isEmpty(data)) {
            const exists = await this.client.exists(rootKey);
            if (exists || !type)
                return null;
            return type === Reference_1.ReferenceType.ARRAY ? [] : {};
        }
        if (depth < 0 || currentDepth < depth) {
            const nested = [];
            for (const [key, val] of Object.entries(data)) {
                if (Raw_1.default.is(val)) {
                    data[key] = new Raw_1.default(val).value;
                }
                else if (Reference_1.default.is(val)) {
                    const { type, key: newKey } = new Reference_1.default(val);
                    nested.push([key, this._get(newKey, { type, depth, currentDepth: currentDepth + 1 })]);
                }
                else {
                    throw new Error(`unrecognized hash entry "${key}"."${val}" on key ${rootKey}`);
                }
            }
            await Promise.all(nested.map(async ([key, call]) => data[key] = await call));
        }
        return type === Reference_1.ReferenceType.ARRAY ? Object.values(data) : data;
    }
    incr(key, amt = 1) {
        if (!key.includes('.'))
            return Promise.reject(new Error(`key "${key}" does not contain any fields`));
        const isFloat = Math.floor(amt) !== amt;
        const route = key.split('.');
        const field = route.pop();
        if (field && route.length) {
            if (isFloat)
                return this.client.hincrbyfloat(route.join('.'), field, amt);
            return this.client.hincrby(route.join('.'), field, amt);
        }
        return Promise.reject(new Error(`error parsing key "${key}" for increment`));
    }
    keys(key) {
        return this.client.hkeys(key);
    }
    size(key) {
        return this.client.hlen(key);
    }
}
exports.default = Rejects;
exports.Rejects = Rejects;

//# sourceMappingURL=index.js.map
